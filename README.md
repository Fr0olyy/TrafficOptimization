# Quantum Traffic Optimizer - атомикХак 2025

## 🚀 Обзор проекта

**Quantum Traffic Optimizer** — это гибридное решение для оптимизации дорожного трафика в крупных городах, сочетающее классические алгоритмы оптимизации с квантовыми вычислениями на базе MIREA Quantum Computer.

### Основная идея

Система решает задачу одновременной оптимизации маршрутов для 500+ автомобилей с учетом динамических пробок. Вместо наивного поиска "кратчайшего пути" для каждой машины независимо, используется **итеративный алгоритм**, который:

1. Начинает с начальных кратчайших путей
2. На каждой итерации пересчитывает "загруженность" каждой дороги
3. Переблокирует часть машин на менее загруженные маршруты
4. Повторяет процесс 15 раз, достигая локально оптимального решения

**Результат**: сумма всех времен в пути (метрика `final_cost`) снижается на 40-50% по сравнению с наивным подходом.

---

## 🏗️ Архитектура системы

```
┌─────────────────────────────────────────────────────────┐
│                  Frontend (Vue.js/React)                │
│              (веб-интерфейс на http://localhost:9000)   │
└────────────────────────┬────────────────────────────────┘
                         │ CSV file upload
                         ▼
┌─────────────────────────────────────────────────────────┐
│        Go Backend (main.go)                             │
│      ┌──────────────────────────────────────┐           │
│      │ /process endpoint (CSV → JSON)       │           │
│      │ - Разбирает CSV файл                 │           │
│      │ - Запускает Python runner.py         │           │
│      │ - Возвращает результаты на frontend  │           │
│      └──────────────────────────────────────┘           │
└────────────────────────┬────────────────────────────────┘
                         │ subprocess.Run
                         ▼
┌──────────────────────────────────────────────────────────┐
│     Python Backend Pipeline (py/)                        │
│                                                          │
│  ┌─────────────────────────────────────────────────┐     │
│  │ 1. CSV Parsing (csv_parser.py)                  │     │
│  │    └─ Парсит граф и 500 маршрутов               │     │
│  └─────────────────────────────────────────────────┘     │
│                         ▼                                │
│  ┌─────────────────────────────────────────────────┐     │
│  │ 2. Classical Solver (traffic_optimizer.py)      │     │
│  │    └─ 15 итераций оптимизации с учетом пробок   │     │
│  │    └─ Final cost: 933844 (хороший результат)    │     │
│  └─────────────────────────────────────────────────┘     │
│                         ▼                                │
│  ┌─────────────────────────────────────────────────┐     │
│  │ 3. QASM Generation (для демо 10 маршрутов)      │     │
│  │    ├─ qubo_formulator.py → QUBO модель          │     │
│  │    ├─ qasm_exporter.py → QASM схема             │     │
│  │    └─ Сохранить в /tmp/qasm_schemes/            │     │
│  └─────────────────────────────────────────────────┘     │
│                         ▼                                │
│  ┌─────────────────────────────────────────────────┐     │
│  │ 4. MIREA Integration                            │     │
│  │    └─ mirea_quantum_adapter.py                  │     │
│  │    └─ Отправить на реальный квантовый ПК        │     │
│  │    └─ Получить метрики успешного выполнения     │     │
│  └─────────────────────────────────────────────────┘     │
│                         ▼                                │
│  ┌─────────────────────────────────────────────────┐     │
│  │ 5. Results Assembly (runner.py)                 │     │
│  │    └─ JSON с результатами + CSV submission      │     │
│  └─────────────────────────────────────────────────┘     │
└─────────────────────────┬────────────────────────────────┘
                         │ JSON response
                         ▼
         Frontend отображает результаты
         ✅ final_cost ✅ QASM файлы ✅ CSV для загрузки
```

---

## 📋 Требования

- **Docker** (для контейнеризации)
- **Docker Compose** (для оркестрации)
- **Go 1.21+** (если запускать main.go локально без Docker)
- **Python 3.10+** (если запускать runner.py локально)
- **Make** (опционально, для удобства)

---

## 🔧 Установка и запуск

### Вариант 1: Docker Compose (рекомендуется)

```bash
# Клонируйте проект
git clone <ваш-репозиторий>
cd TrafficOptimization

# Запустите проект
docker-compose up -d --build

# Откройте в браузере
open http://localhost:9000
```

### Вариант 2: Локальный запуск (для разработки)

```bash
# Соберите Go backend
cd backend
go build -o server

# Запустите Go server
./server

# В другом терминале запустите Python runner напрямую
cd py
python3 runner.py --csv-file input.csv --use-mirea --mirea-email=... --mirea-password=...
```

---

## 📊 Использование

### 1. Подготовка входного CSV файла

Файл должен содержать 3 обязательных колонки:

| graph_index | graph_matrix                               | routes_start_end      |
| ----------- | ------------------------------------------ | --------------------- |
| 5           | `1 2 3 4 ... 50 51 52 ... (матрица 10x10)` | `0 1 2 3 4 5 ... 9 8` |

**Формат:**

- `graph_index`: Целый номер графа
- `graph_matrix`: Квадратная матрица смежности (200 элементов для 10x10 графа, 250000 для 500x500)
- `routes_start_end`: Пары узлов (старт, конец) для каждого из 500 маршрутов

### 2. Загрузите файл через веб-интерфейс

Откройте `http://localhost:9000` и:

- Выберите CSV файл
- Нажмите "Upload and Process"
- Дождитесь результатов (~90 секунд)

### 3. Получите результаты

**JSON ответ содержит:**

```json
{
  "ok": true,
  "downloads": { "submission_csv": "..." },
  "elapsed_ms": 90102,
  "perGraph": [
    {
      "graph_index": 5,
      "stats": { "final_cost": 1080606.25 },
      "mirea_metric_samples": [ ... ]
    }
  ],
  "summary": { ... }
}
```

**Скачайте submission.csv** с использованием ID из `downloads.submission_csv`

### 4. Получите QASM файлы

```bash
./get_qasm.sh
# или
docker cp quantum-optimizer:/tmp/qasm_schemes ./saved_qasm_schemes
```

---

## 🎛️ Параметры запуска

### Через веб-интерфейс (переменные окружения в docker-compose.yml)

```yaml
environment:
  - MIREA_EMAIL=your-email@gmail.com
  - MIREA_PASSWORD=your-password
  - MIREA_SHOTS=1024 # Повторения на квантовом ПК
  - DEFAULT_QAOA_LAYERS=2 # Слои QAOA схемы
```

### Через Python runner.py (командная строка)

```bash
python3 runner.py \
  --csv-file input.csv \
  --iterations 15 \
  --reroute-fraction 0.1 \
  --use-mirea \
  --mirea-email email@gmail.com \
  --mirea-password password \
  --mirea-shots 1024 \
  --mirea-samples 2 \
  --max-total-mirea-calls 10 \
  --p-layers 1
```

**Параметры:**

- `--iterations`: Число итераций оптимизации (15 по умолчанию)
- `--reroute-fraction`: Доля машин для переблокировки на каждой итерации (0.1 = 10%)
- `--mirea-samples`: Количество маршрутов для демонстрации на MIREA
- `--max-total-mirea-calls`: Максимальное число запросов к квантовому ПК (лимит 10)
- `--p-layers`: QAOA слои для квантовой схемы

---

## 📁 Структура проекта

```
TrafficOptimization/
├── README.md                      # ← Этот файл (общее описание)
├── docker-compose.yml             # Конфигурация Docker
├── Dockerfile                     # Образ контейнера
├── Makefile                       # Удобные команды (make build, make run, etc)
│
├── backend/                       # Go веб-сервер
│   ├── main.go                   # Главный сервер (/process endpoint)
│   ├── go.mod
│   └── go.sum
│
├── py/                            # Python оптимизационная часть
│   ├── README.md                 # ← Техническое описание для backend
│   ├── runner.py                 # Основной оркестратор
│   ├── csv_parser.py             # Парсинг входных данных
│   ├── traffic_optimizer.py      # Итеративный алгоритм оптимизации
│   ├── qubo_formulator.py        # QUBO формулировка
│   ├── qasm_exporter.py          # QASM генератор
│   └── mirea_quantum_adapter.py  # Интеграция с MIREA
│
├── web/                           # Фронтенд (HTML/CSS/JS)
│   ├── index.html
│   ├── style.css
│   └── script.js
│
├── saved_qasm_schemes/            # Папка с экспортированными QASM файлами (создается после ./get_qasm.sh)
│
└── get_qasm.sh                    # Скрипт для копирования QASM файлов из контейнера
```

---

## 🚀 Готовые команды (Makefile)

```bash
make build              # Собрать Docker образ
make run                # Запустить контейнер (docker-compose up)
make stop               # Остановить контейнер
make clean              # Остановить и удалить контейнер
make logs               # Показать логи
make get-qasm           # Скопировать QASM файлы из контейнера
make test-api           # Протестировать API
```

**Пример:**

```bash
make build && make run
# Откройте http://localhost:9000
```

---

## 📊 Ожидаемые результаты

| Метрика                   | Ожидаемое значение | Ваш результат |
| ------------------------- | ------------------ | ------------- |
| **final_cost** (хороший)  | < 1200000          | ✅ 1080606    |
| **final_cost** (отличный) | < 1000000          | ✅ 933844     |
| **elapsed_ms**            | < 150 сек          | ✅ 90 сек     |
| **ok**                    | true               | ✅ true       |
| **MIREA success**         | true               | ✅ true       |
| **QASM файлы**            | >0 файлов          | ✅ 10+ файлов |

---

## 🔬 Как работает алгоритм?

### Классический итеративный решатель

1. **Инициализация**: Найти кратчайший путь для каждой машины (Dijkstra)
2. **Итерация**:
   - Пересчитать "загруженность" каждой дороги (сколько машин уже ее используют)
   - Перестроить матрицу стоимостей: `cost = base_cost × congestion²`
   - Выбрать 10% машин случайно
   - Для каждой машины найти новый кратчайший путь
   - Обновить их маршруты
3. **Повторить 15 раз**

### Математическая формула

Для каждой дороги `(i, j)`:

```
cost[i,j] = base_distance[i,j] × (congestion_count[i,j])²
```

Где `congestion_count` = число машин, уже использующих эту дорогу.

**Итоговая метрика**:

```
final_cost = Σ (путь каждой машины в новой матрице стоимостей)
```

Цель: минимизировать `final_cost`.

---

## 🔗 API

### POST /process

**Request:**

```
Content-Type: multipart/form-data
- file: CSV файл (обязательно)
```

**Response:**

```json
{
  "ok": true,
  "downloads": { "submission_csv": "ID" },
  "elapsed_ms": 90102,
  "perGraph": [ ... ],
  "summary": { ... }
}
```

### GET /download?id=...

Скачивает файл по ID из `downloads.submission_csv`

---

## 🐛 Отладка

### Логи контейнера

```bash
docker-compose logs quantum-optimizer
```

### Проверка QASM файлов

```bash
# После ./get_qasm.sh проверьте содержимое
cat saved_qasm_schemes/graph_5_route_0.qasm
```

### Тестирование API

```bash
curl -X POST -F "file=@input.csv" http://localhost:9000/process
```

---

## 📚 Дополнительная документация

- **Backend.md** (в папке `py/`) — техническое описание каждого Python модуля
- **swagger.yaml** — OpenAPI спецификация
- **backend-json-guide.md** — подробное описание JSON ответа

---

## 👥 Команда проекта

- Разработчик: Ваше имя
- Технология: Go + Python + Quantum (MIREA)
- Ивент: атомикХак 2025

---

## 📄 Лицензия

MIT License — используйте свободно!

---

## 🎯 Следующие шаги для хакатона

1. ✅ Убедитесь, что Docker запущен
2. ✅ Запустите проект: `docker-compose up -d --build`
3. ✅ Откройте http://localhost:9000
4. ✅ Загрузите CSV файл и обработайте
5. ✅ Скопируйте QASM файлы: `./get_qasm.sh`
6. ✅ Скачайте submission.csv
7. ✅ Подготовьте презентацию с результатами
8. ✅ **ПОБЕДИТЕ! 🏆**
